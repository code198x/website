---
import { getCollection, type CollectionEntry } from 'astro:content';
// import Layout from '../../layouts/Layout.astro'; // Using the default layout
import BlogLayout from '../../layouts/BlogLayout.astro'; // Use specific layout
import { findRelated } from '../../utils/relatedContent'; // Import the utility

// Define the structure for related items returned by the utility
interface RelatedItem {
  slug: string;
  title: string;
  collection: string;
}

// Generate pages for all posts
export async function getStaticPaths() {
  const allPosts = await getCollection('posts');
  const allTutorials = await getCollection('tutorials'); // Fetch tutorials
  
  // Combine all content that has tags and can be related
  const allTaggableContent = [...allPosts, ...allTutorials];

  // Sort posts by date for next/prev logic (only needed for posts on this page)
  const sortedPosts = [...allPosts].sort((a, b) => a.data.publishDate.valueOf() - b.data.publishDate.valueOf());
  
  return allPosts.map((entry) => {
    // Find the index in the *sorted posts* array for correct next/prev
    const sortedIndex = sortedPosts.findIndex(p => p.slug === entry.slug);
    const prev = sortedIndex > 0 ? { slug: sortedPosts[sortedIndex - 1].slug, title: sortedPosts[sortedIndex - 1].data.title } : null;
    const next = sortedIndex < sortedPosts.length - 1 ? { slug: sortedPosts[sortedIndex + 1].slug, title: sortedPosts[sortedIndex + 1].data.title } : null;
    
    // Find related content using the combined list
    const relatedPosts = findRelated({ 
      currentItem: entry, 
      allItems: allTaggableContent, // Pass the combined list
      limit: 5 
    });

    return {
      params: { slug: entry.slug }, 
      props: { 
        entry, 
        // contentType is now handled within BlogLayout
        prev, 
        next, 
        relatedPosts // Pass related items (mixed types possible)
      },
    };
  });
}

interface Props {
  entry: CollectionEntry<'posts'>;
  // contentType: string; // No longer needed here
  prev: { slug: string; title: string } | null;
  next: { slug: string; title: string } | null;
  relatedPosts: RelatedItem[]; // Use the updated interface
}

const { entry, prev, next, relatedPosts } = Astro.props; // Removed contentType and destructure relatedPosts
const { Content } = await entry.render();
---
<BlogLayout 
  entry={entry}
  prev={prev}
  next={next}
  relatedPosts={relatedPosts} // Pass related items (mixed types possible)
>
  {/* Header (title, date) is now handled in BlogLayout */}
	<Content />
</BlogLayout> 